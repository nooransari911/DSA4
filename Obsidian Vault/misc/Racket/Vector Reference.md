A vector is a fixed-length array with constant-time access and update of the vector slots, which are numbered from 0 to one less than the number of slots in the vector.

Two vectors are [equal?](Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29) if they have the same length, and if the values in corresponding slots of the vectors are [equal?](Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29).

A vector can be mutable or immutable. When an immutable vector is provided to a procedure like [vector-set!](#%28def._%28%28quote._~23~25kernel%29._vector-set%21%29%29), the [exn:fail:contract](exns.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._exn~3afail~3acontract%29%29) exception is raised. Vectors generated by the default reader (see [Reading Strings](reader.html#%28part._parse-string%29)) are immutable. Use [immutable?](booleans.html#%28def._%28%28quote._~23~25kernel%29._immutable~3f%29%29) to check whether a vector is immutable.

A vector can be used as a single-valued sequence (see [Sequences](sequences.html)). The elements of the vector serve as elements of the sequence. See also [in-vector](sequences.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._in-vector%29%29).

A literal or printed vector starts with #(, optionally with a number between the # and (. See [Reading Vectors](reader.html#%28part._parse-vector%29) for information on [read](Reading.html#%28def._%28%28quote._~23~25kernel%29._read%29%29)ing vectors and [Printing Vectors](printing.html#%28part._print-vectors%29) for information on [print](Writing.html#%28def._%28%28quote._~23~25kernel%29._print%29%29)ing vectors.


<html>
	<h2 style="font-family:courier;color:#FF0064">
		Is vector?
	</h2>
</html>

```
(vector? v) → boolean?
	v : any/c
Returns #t if v is a vector, #f otherwise.
```


<html>
	<h2 style="font-family:courier;color:#FF0064">
		Creating vectors
	</h2>
</html>

```
Creating vectors::
//make vector initialized with v
(make-vector size [v]) -> vector?
	v : any/c = 0
	size: exact-nonnegative-integer?
Returns a mutable vector with size slots, where all slots are initialized to contain v. Note that v is shared for all elements, so for mutable data, mutating an element will affect other elements.


(vector v ...) --> vector?
	v : any/c
Returns a newly allocated mutable vector with as many slots as provided vs, where the slots are initialized to contain the given vs in order.

(vector-immutable v ...) --> (and/c vector? immutable?)
	v : any/c
Returns a newly allocated immutable vector with as many slots as provided vs, where the slots are initialized to contain the given vs in order.
```


<html>
	<h2 style="font-family:courier;color:#FF0064">
		Accessing elements and length of vector::
	</h2>
</html>

```
//length
(vector-length vec) --> exact-nonnegative-number?
	vec: vector?
Returns the length of vec (i.e., the number of slots in the vector)


//access element in vector vec at index pos
(vector-ref vec pos) --> any/c
	vec: vector?
	pos: exact-nonngeative-number?
Returns the element in slot pos of vec. The first slot is position 0, and the last slot is one less than (vector-length vec).

//modify index pos in vector vec with v
(vector-set! vec pos v) → void?
	vec : (and/c vector? (not/c immutable?))
	pos : exact-nonnegative-integer?
	v : any/c
Updates the slot pos of vec to contain v.

(vector*-length), (vector*-ref), (vector*-set!) work similarly except on vectors that are not impersonators.




//replaces old value by new value at index pos
(vector-cas! vec pos old-v new-v) → boolean?
	old-v: any/c
	new-v: any/c
	vec: (and/c vector? (not/c immutable?) (not/c impersonator?))
	pos: exact-nonnegative-number?
Compare and set operation for vectors. Replace old-v by new-v if old-v is found at pos
```


<html>
	<h2 style="font-family:courier;color:#FF0064">
		To and from various sub data structures
	</h2>
</html>

```
//to list
(vector->list vec) --> list?
	vec: vector?
Returns a list with the same length and elements as vec.


//from list
(list->vector lst) --> vector?
	lst: list?
Returns a mutable vector with the same length and elements as lst.


//to immutable
(vector->immutable-vector vec) --> (and/c vector? immutable?)
	vec: vector?
Returns an immutable vector with the same length and elements as vec. If vec is itself immutable, then it is returned as the result.


//fill with v
(vector-fill! vec v) --> void?
	vec: (and/c vector? (not/c immutable?))
	v: any/c
Changes all slots of vec to contain v
```

<html>
	<h2 style="font-family:courier;color:#FF0064">
		Additional
	</h2>
</html>

```
require racker/vector
```

```
//fresh mapping on vectors
(vector-map proc vec0 vec1 vec2 vec3 ...) --> vector?
	veco, vec1, vec2, vec2, ...: vector?
	proc: procedure?
Applies proc to the elements of the vecs from the first elements to the last. The proc argument must accept the same number of arguments as the number of supplied vecs, and all vecs must have the same number of elements. The result is a fresh vector containing each result of proc in order.

example:
> (vector-map + #(1 2) #(3 4) #(1 2) #(3 4))
#(8 12)


//modification mapping on vectors
(vector-map! proc vec0 vec1 vec2 vec3 ...) --> vector?
	veco, vec1, vec2, vec2, ...: vector?
	proc: procedure?
Like vector-map, but result of proc is inserted into the first vec at the index that the arguments to proc were taken from. The result is the first vec.

example:
> (define v (vector 1 2 3 4))
> (vector-map! add1 v)
#(2 3 4 5)
> v
#(2 3 4 5)


//filter
(vector-filter pred vec) --> vector?
	pred: procedure?
	vec: vector?
Returns a fresh vector with the elements of vec for which pred produces a true value. The pred procedure is applied to each element from first to last.

(vector-filter-not pred vec) --> vector?
	pred: procedure?
	vec: vector?
Like vector-filter, but the meaning of the pred predicate is reversed: the result is a vector of all items for which pred returns #f.


(vector-count pred vec0 vec1 ....) --> vector?
	pred: procedure?
	vec0, vec1, ....: vector?
Returns the number of elements of the vec .... (taken in parallel) on which proc does not evaluate to #f.





//vector sort
(vector-sort vec less-than? [start end #:key key #:cache-keys? cache-keys?]) → vector?
	less-than?: (any/c any/c . -> . any/c)
	vec: vector?
	start: exact-nonnegative-number? = 0
	end: exact-nonnegative-number? = (vector-length vec)
	key: (any/c any/c . -> . any/c) = (lambda (x) x)
	cache-keys?: boolean? = #f
Like sort, but operates on vectors; a fresh vector of length (- end start) is returned containing the elements from indices start (inclusive) through end (exclusive) of vec, but in sorted order (i.e., vec is not modified). This sort is stable (i.e., the order of “equal” elements is preserved).

(vector-sort! vec less-than? [start end #:key key #:cache-keys? cache-keys?]) → void?
	less-than?: (any/c any/c . -> . any/c)
	vec: vector?
	start: exact-nonnegative-number? = 0
	end: exact-nonnegative-number? = (vector-length vec)
	key: (any/c any/c . -> . any/c) = (lambda (x) x)
	cache-keys?: boolean? = #f
Like vector-sort, but updates indices start (inclusive) through end (exclusive) of vec by sorting them according to the less-than? procedure.






//vector append
(vector-append vec0 vec1 ....) --> vector?
Creates a fresh vector that contains all of the elements of the given vectors in order.







//vector copy to existing vector
(vector-copy! dest dest-start src [src-start src-end]) → void?
	dest: (and/c vector? (not/c immutable?))
	dest-start: exact-nonnegative-number?
	src: vector?
	src-start: exact-nonnegative-number? = 0
	src-end: exact-nonnegative-number? = (vector-length src)
Changes the elements of dest starting at position dest-start to match the elements in src from src-start (inclusive) to src-end (exclusive). 
The vectors dest and src can be the same vector, and in that case the destination region can overlap with the source region; the destination elements after the copy match the source elements from before the copy. If any of dest-start, src-start, or src-end are out of range (taking into account the sizes of the vectors and the source and destination regions), the exn:fail:contract exception is raised.




//vector copy to fresh vector
(vector-copy src [start end]) → vector?
	src: vector?
	start: exact-nonnegative-number? = 0
	end: exact-nonnegative-number? = (vector-length src)
Creates a fresh vector of size ([-](https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29) end start), with all of the elements of vec from start (inclusive) to end (exclusive).

```